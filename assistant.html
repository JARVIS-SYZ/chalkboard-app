import React, { useCallback, useEffect, useRef, useState } from 'react';
import {
  SafeAreaView,
  View,
  Text,
  Pressable,
  StyleSheet,
  StatusBar,
  TouchableOpacity,
  Dimensions,
  ImageBackground,
} from 'react-native';
import { Canvas, Path as SkPath, Skia, Group, SkPath as SkiaPath } from '@shopify/react-native-skia';
import database, { firebase, FirebaseDatabaseTypes } from '@react-native-firebase/database';
import QRCode from 'react-native-qrcode-svg';
import Slider from '@react-native-community/slider';

const DB_URL = 'https://syz-test-default-rtdb.asia-southeast1.firebasedatabase.app/';

// í™”ë©´ í¬ê¸°
const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// ===== íƒ€ì… ì •ì˜ =====
type ScreenType = 'qr' | 'chalkboard';
type ToolType = 'chalk' | 'eraser';

interface Point {
  x: number;
  y: number;
  t?: number;
}

interface Stroke {
  tool?: string;
  points: Point[];
  width?: number;
  canvasWidth?: number;
  canvasHeight?: number;
  order?: number; // ë Œë”ë§ ìˆœì„œ
}

interface Payload {
  type: string;
  data?: Stroke[];
  from?: string;
  clientId?: string;
  seq?: number;
  ts?: any;
}

interface Layer {
  kind: 'chalk' | 'eraser';
  corePath?: SkiaPath;
  dustPath?: SkiaPath;
  path?: SkiaPath;
  order?: number; // ë ˆì´ì–´ ìˆœì„œ
}

// ===== ë¶„í•„ ì„¤ì • (ìµœì í™”ë¨) =====
const CHALK_CORE = 'rgba(230, 235, 228, 0.60)';
const CHALK_DUST = 'rgba(230, 235, 228, 0.22)';

const CHALK = {
  baseWidth: 15,
  thickWidth: 22,
  density: 18,
  spread: 0.55,
  roughness: 0.9,
  spacing: 4,
};

function makeRoomId(len: number = 6): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let out = '';
  for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
  return out;
}

function rand(min: number, max: number): number {
  return Math.random() * (max - min) + min;
}

function addCircleCompat(path: SkiaPath, x: number, y: number, r: number): void {
  if (typeof (path as any).addCircle === 'function') {
    (path as any).addCircle(x, y, r);
  } else {
    const rect = Skia.XYWHRect(x - r, y - r, r * 2, r * 2);
    path.addOval(rect);
  }
}

interface SprayParticlesParams {
  x: number;
  y: number;
  width: number;
  corePath: SkiaPath;
  dustPath: SkiaPath;
  isThick: boolean;
}

function sprayParticles({ x, y, width, corePath, dustPath, isThick }: SprayParticlesParams): void {
  const baseCount = CHALK.density * (isThick ? 1.25 : 1.0);
  const count = Math.floor(baseCount);

  const coreCount = Math.floor(count * 0.55);
  const dustCount = Math.max(0, count - coreCount);

  for (let i = 0; i < coreCount; i++) {
    const a = Math.random() * Math.PI * 2;
    const r = Math.sqrt(Math.random()) * width * (CHALK.spread * 0.45);
    const px = x + Math.cos(a) * r;
    const py = y + Math.sin(a) * r;
    const pr = rand(0.35, 1.35) * (isThick ? 1.35 : 1.0);
    addCircleCompat(corePath, px, py, pr);
  }

  for (let i = 0; i < dustCount; i++) {
    const a = Math.random() * Math.PI * 2;
    const r = Math.sqrt(Math.random()) * width * (CHALK.spread * 0.95);
    const px = x + Math.cos(a) * r;
    const py = y + Math.sin(a) * r;
    const pr = rand(0.25, 0.9) * (isThick ? 1.15 : 1.0);
    addCircleCompat(dustPath, px, py, pr);
  }
}

export default function App() {
  // ===== ëª¨ë“  State (í•­ìƒ ê°™ì€ ìˆœì„œë¡œ) =====
  const [currentScreen, setCurrentScreen] = useState<ScreenType>('qr');
  const [roomId, setRoomId] = useState<string>('');
  const [shareUrl, setShareUrl] = useState<string>('');
  const [dbConnected, setDbConnected] = useState<boolean>(false);
  const [assistantOnlineCount, setAssistantOnlineCount] = useState<number>(0);
  const [externalLayers, setExternalLayers] = useState<Layer[]>([]); // ì™¸ë¶€ ë ˆì´ì–´
  const [localLayers, setLocalLayers] = useState<Layer[]>([]); // ë¡œì»¬ ë ˆì´ì–´
  const [globalEraserLayers, setGlobalEraserLayers] = useState<Layer[]>([]); // iPad ì „ì—­ ì§€ìš°ê°œ
  const [penWidth, setPenWidth] = useState<number>(15);
  const [eraserWidth, setEraserWidth] = useState<number>(40);
  const [currentTool, setCurrentTool] = useState<ToolType>('chalk');
  const [isDrawing, setIsDrawing] = useState<boolean>(false);
  const [localStrokes, setLocalStrokes] = useState<Stroke[]>([]);
  const [externalStrokes, setExternalStrokes] = useState<Stroke[]>([]);

  // ===== ëª¨ë“  Ref (í•­ìƒ ê°™ì€ ìˆœì„œë¡œ) =====
  const externalLayersRef = useRef<Layer[]>([]);
  const localLayersRef = useRef<Layer[]>([]);
  const currentStrokeRef = useRef<Point[]>([]);
  const baseLayerCountRef = useRef<number>(0);
  const lastExternalTsRef = useRef<number>(0);
  const lastRenderTimeRef = useRef<number>(0);
  const globalOrderRef = useRef<number>(0); // ì „ì—­ ë ˆì´ì–´ ìˆœì„œ ì¹´ìš´í„°
  const dbRef = useRef<any>(null);
  const pollTimerRef = useRef<number | null>(null);
  const lastLatestTsRef = useRef<number>(0);
  const tapCountRef = useRef<number>(0);
  const tapTimerRef = useRef<number | null>(null);
  const leftTapCountRef = useRef<number>(0);
  const leftTapTimerRef = useRef<number | null>(null);
  const leftLongPressTimerRef = useRef<number | null>(null);
  const leftLongPressStartRef = useRef<number>(0);
  const isInitializedRef = useRef(false);

  // ===== ìƒìˆ˜ =====
  const renderThrottleMs = 50;
  
  const getDb = useCallback(() => {
    if (!dbRef.current) {
      console.log('ğŸ”¥ Firebase ì´ˆê¸°í™” ì¤‘...');
      dbRef.current = firebase.app().database(DB_URL);
    }
    return dbRef.current;
  }, []);

  // ===== useEffect =====
  useEffect(() => {
    externalLayersRef.current = externalLayers;
  }, [externalLayers]);

  useEffect(() => {
    localLayersRef.current = localLayers;
  }, [localLayers]);

  // localStrokesë‚˜ externalStrokesê°€ ë³€ê²½ë  ë•Œ ìë™ ë Œë”ë§
  useEffect(() => {
    console.log('ğŸ–ï¸ useEffect renderStrokes', `ë¡œì»¬=${localStrokes.length}, ì™¸ë¶€=${externalStrokes.length}`);

    // ì™¸ë¶€ ë°ì´í„°ì—ì„œ ì›¹ ìº”ë²„ìŠ¤ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    const firstWebStroke = externalStrokes.find(s => s.canvasWidth && s.canvasHeight);
    const webCanvasWidth = firstWebStroke?.canvasWidth;
    const webCanvasHeight = firstWebStroke?.canvasHeight;

    // 1. ì™¸ë¶€(iPhone) ë°ì´í„° ë Œë”ë§
    const newExternalLayers: Layer[] = [];
    externalStrokes.forEach((stroke) => {
      let scaleX = 1;
      let scaleY = 1;
      
      if (webCanvasWidth && webCanvasHeight && stroke.canvasWidth) {
        scaleX = SCREEN_WIDTH / webCanvasWidth;
        scaleY = SCREEN_HEIGHT / webCanvasHeight;
      }

      if (stroke.tool === 'eraser') {
        const eraserPath = Skia.Path.Make();
        stroke.points.forEach((pt, idx) => {
          const scaledX = pt.x * scaleX;
          const scaledY = pt.y * scaleY;
          
          if (idx === 0) {
            eraserPath.moveTo(scaledX, scaledY);
          } else {
            eraserPath.lineTo(scaledX, scaledY);
          }
        });

        newExternalLayers.push({
          kind: 'eraser',
          path: eraserPath,
        });
      } else {
        const { corePath, dustPath } = renderStrokeToPath(stroke, scaleX, scaleY, penWidth);
        
        newExternalLayers.push({
          kind: 'chalk',
          corePath,
          dustPath,
        });
      }
    });

    // 2. ë¡œì»¬(iPad) ë°ì´í„° ë Œë”ë§ - ë¶„í•„/ì§€ìš°ê°œë¥¼ ìˆœì„œëŒ€ë¡œ ì„ì–´ì„œ
    const newLocalLayers: Layer[] = [];
    
    localStrokes.forEach((stroke) => {
      if (stroke.tool === 'eraser') {
        const eraserPath = Skia.Path.Make();
        stroke.points.forEach((pt, idx) => {
          if (idx === 0) {
            eraserPath.moveTo(pt.x, pt.y);
          } else {
            eraserPath.lineTo(pt.x, pt.y);
          }
        });

        newLocalLayers.push({
          kind: 'eraser',
          path: eraserPath,
        });
      } else {
        const { corePath, dustPath } = renderStrokeToPath(stroke);
        
        newLocalLayers.push({
          kind: 'chalk',
          corePath,
          dustPath,
        });
      }
    });

    // ë³„ë„ stateë¡œ ì €ì¥
    setExternalLayers(newExternalLayers);
    setLocalLayers(newLocalLayers);
    setGlobalEraserLayers([]); // ì‚¬ìš©í•˜ì§€ ì•ŠìŒ

    console.log('âœ… ë Œë”ë§ ì™„ë£Œ:', `ì™¸ë¶€=${newExternalLayers.length}, ë¡œì»¬=${newLocalLayers.length}`);
  }, [localStrokes, externalStrokes, penWidth, renderStrokeToPath]);

  // ===== í•¨ìˆ˜ë“¤ =====
  const clearCanvas = useCallback(() => {
    console.log('ğŸ§½ clearCanvas()');
    externalLayersRef.current = [];
    localLayersRef.current = [];
    setExternalLayers([]);
    setLocalLayers([]);
    setGlobalEraserLayers([]);
    setLocalStrokes([]);
    setExternalStrokes([]);
    lastExternalTsRef.current = 0;
  }, []);

  const renderStrokeToPath = useCallback((stroke: Stroke, scaleX: number = 1, scaleY: number = 1, overrideWidth?: number) => {
    const corePath = Skia.Path.Make();
    const dustPath = Skia.Path.Make();
    
    const actualWidth = overrideWidth !== undefined ? overrideWidth : (stroke.width || 15);
    const isThick = actualWidth > 16;

    if (!stroke.points || stroke.points.length === 0) {
      return { corePath, dustPath };
    }

    stroke.points.forEach((pt, idx) => {
      if (idx === 0) return;

      const prevPt = stroke.points[idx - 1];
      
      const x = pt.x * scaleX;
      const y = pt.y * scaleY;
      const prevX = prevPt.x * scaleX;
      const prevY = prevPt.y * scaleY;
      
      const dx = x - prevX;
      const dy = y - prevY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      const steps = Math.max(1, Math.floor(dist / CHALK.spacing));

      for (let s = 0; s <= steps; s++) {
        const t = s / steps;
        const interpolatedX = prevX + dx * t;
        const interpolatedY = prevY + dy * t;

        const jitterX = rand(-CHALK.roughness, CHALK.roughness);
        const jitterY = rand(-CHALK.roughness, CHALK.roughness);

        sprayParticles({
          x: interpolatedX + jitterX,
          y: interpolatedY + jitterY,
          width: actualWidth,
          corePath,
          dustPath,
          isThick,
        });
      }
    });

    return { corePath, dustPath };
  }, []);

  const renderStrokes = useCallback((localData: Stroke[], externalData: Stroke[]) => {
    console.log('ğŸ–ï¸ renderStrokes()', `ë¡œì»¬=${localData.length}, ì™¸ë¶€=${externalData.length}`);

    // ì™¸ë¶€ ë°ì´í„°ì—ì„œ ì›¹ ìº”ë²„ìŠ¤ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
    const firstWebStroke = externalData.find(s => s.canvasWidth && s.canvasHeight);
    const webCanvasWidth = firstWebStroke?.canvasWidth;
    const webCanvasHeight = firstWebStroke?.canvasHeight;

    // 1. ì™¸ë¶€(iPhone) ë°ì´í„° ë Œë”ë§
    const newExternalLayers: Layer[] = [];
    externalData.forEach((stroke) => {
      let scaleX = 1;
      let scaleY = 1;
      
      if (webCanvasWidth && webCanvasHeight && stroke.canvasWidth) {
        scaleX = SCREEN_WIDTH / webCanvasWidth;
        scaleY = SCREEN_HEIGHT / webCanvasHeight;
      }

      if (stroke.tool === 'eraser') {
        const eraserPath = Skia.Path.Make();
        stroke.points.forEach((pt, idx) => {
          const scaledX = pt.x * scaleX;
          const scaledY = pt.y * scaleY;
          
          if (idx === 0) {
            eraserPath.moveTo(scaledX, scaledY);
          } else {
            eraserPath.lineTo(scaledX, scaledY);
          }
        });

        newExternalLayers.push({
          kind: 'eraser',
          path: eraserPath,
        });
      } else {
        const finalWidth = penWidth;
        const { corePath, dustPath } = renderStrokeToPath(stroke, scaleX, scaleY, finalWidth);
        
        newExternalLayers.push({
          kind: 'chalk',
          corePath,
          dustPath,
        });
      }
    });

    // 2. ë¡œì»¬(iPad) ë°ì´í„° ë Œë”ë§
    const newLocalLayers: Layer[] = [];
    localData.forEach((stroke) => {
      if (stroke.tool === 'eraser') {
        const eraserPath = Skia.Path.Make();
        stroke.points.forEach((pt, idx) => {
          if (idx === 0) {
            eraserPath.moveTo(pt.x, pt.y);
          } else {
            eraserPath.lineTo(pt.x, pt.y);
          }
        });

        newLocalLayers.push({
          kind: 'eraser',
          path: eraserPath,
        });
      } else {
        const { corePath, dustPath } = renderStrokeToPath(stroke);
        
        newLocalLayers.push({
          kind: 'chalk',
          corePath,
          dustPath,
        });
      }
    });

    // ë³„ë„ stateë¡œ ì €ì¥
    setExternalLayers(newExternalLayers);
    setLocalLayers(newLocalLayers);

    console.log('âœ… ë Œë”ë§ ì™„ë£Œ:', `ì™¸ë¶€=${newExternalLayers.length}, ë¡œì»¬=${newLocalLayers.length}`);
  }, [penWidth, renderStrokeToPath]);

  const applyPayload = useCallback(
    (payload: Payload) => {
      console.log(`âœ… applyPayload type=`, payload?.type, `from=`, payload?.from);

      if (!payload || typeof payload !== 'object') return;

      const isFromExternal = payload.from === 'assistant';

      if (payload.type === 'clear') {
        clearCanvas();
        return;
      }
      
      if (payload.type === 'strokes' && payload.data) {
        if (isFromExternal) {
          const currentTs = payload.ts || 0;
          
          // ê°™ì€ íƒ€ì„ìŠ¤íƒ¬í”„ë©´ ì¤‘ë³µì´ë¯€ë¡œ ë¬´ì‹œ
          if (currentTs === lastExternalTsRef.current) {
            console.log('âš ï¸ ì¤‘ë³µ ë°ì´í„° ë¬´ì‹œ (ê°™ì€ íƒ€ì„ìŠ¤íƒ¬í”„)');
            return;
          }
          
          lastExternalTsRef.current = currentTs;
          console.log('ğŸ“± iPhone ë°ì´í„° ìˆ˜ì‹  - externalStrokesì— ëˆ„ì ');
          
          // ì™¸ë¶€ ë°ì´í„°ë¥¼ ëˆ„ì  (ë®ì–´ì“°ê¸° ì•„ë‹˜)
          setExternalStrokes(prev => [...prev, ...payload.data]);
        }
        // ë Œë”ë§ì€ useEffectì—ì„œ ì²˜ë¦¬
        return;
      }
    },
    [clearCanvas],
  );

  const stopPolling = useCallback(() => {
    if (pollTimerRef.current) {
      clearInterval(pollTimerRef.current);
      pollTimerRef.current = null;
      console.log('ğŸ›‘ Polling ì¤‘ì§€');
    }
  }, []);

  const startPolling = useCallback(
    (rid: string) => {
      stopPolling();

      console.log('========================================');
      console.log('ğŸ”„ Polling ì‹œì‘ (1ì´ˆ ê°„ê²©)');
      console.log('ğŸ§© Room ID:', rid);
      console.log('========================================');

      const db = getDb();
      const roomBase = `rooms/${rid}`;

      (async () => {
        try {
          const ipadPresenceRef = db.ref(`${roomBase}/presence/ipad`);
          await ipadPresenceRef.onDisconnect().set({
            online: false,
            ts: database.ServerValue.TIMESTAMP,
          });
          await ipadPresenceRef.set({
            online: true,
            ts: database.ServerValue.TIMESTAMP,
            platform: 'ios',
          });
          console.log('âœ… iPad presence ì„¤ì • ì™„ë£Œ');
        } catch (e: any) {
          console.log('âŒ iPad presence ì„¤ì • ì‹¤íŒ¨:', e?.message);
        }
      })();

      pollTimerRef.current = setInterval(async () => {
        try {
          const latestRef = db.ref(`${roomBase}/latest`);
          const latestSnap = await latestRef.once('value');

          if (latestSnap.exists()) {
            const val = latestSnap.val() as Payload;
            const newTs = val?.ts || 0;

            if (newTs > lastLatestTsRef.current) {
              console.log('ğŸ“¥ ìƒˆë¡œìš´ latest ë°ì´í„° ê°ì§€!', { oldTs: lastLatestTsRef.current, newTs });
              lastLatestTsRef.current = newTs;
              applyPayload(val);
            }
          }

          const presRef = db.ref(`${roomBase}/presence/assistant`);
          const presSnap = await presRef.once('value');
          const presVal = presSnap.val() || {};
          const onlineCount = Object.values(presVal).filter((x: any) => x && x.online === true).length;
          setAssistantOnlineCount(onlineCount);

          const connRef = db.ref('.info/connected');
          const connSnap = await connRef.once('value');
          setDbConnected(!!connSnap.val());
        } catch (e: any) {
          console.log('âš ï¸ Polling ì˜¤ë¥˜:', e?.message);
        }
      }, 1000);
    },
    [applyPayload, getDb, stopPolling],
  );

  const handleConnect = useCallback(async () => {
    const rid = makeRoomId(6);
    setRoomId(rid);

    const url = `https://jarvis-syz.github.io/chalkboard-app/assistant.html?room=${encodeURIComponent(
      rid,
    )}&v=${Date.now()}`;
    setShareUrl(url);

    console.log('ğŸ² Room ID:', rid);
    console.log('ğŸ”— URL:', url);

    lastLatestTsRef.current = 0;

    startPolling(rid);
  }, [startPolling]);

  useEffect(() => {
    return () => stopPolling();
  }, [stopPolling]);
  
  useEffect(() => {
    if (!isInitializedRef.current) {
      isInitializedRef.current = true;
      handleConnect();
    }
  }, [handleConnect]);

  // QR í™”ë©´ ë³µê·€ (ëª¨ì„œë¦¬ 3ë²ˆ íƒ­)
  const handleCornerTap = useCallback(() => {
    tapCountRef.current += 1;
    console.log(`ğŸ‘† ëª¨ì„œë¦¬ íƒ­ ${tapCountRef.current}/3`);

    if (tapTimerRef.current) {
      clearTimeout(tapTimerRef.current);
    }

    if (tapCountRef.current >= 3) {
      console.log('âœ… 3ë²ˆ íƒ­ ê°ì§€ - QR í™”ë©´ìœ¼ë¡œ ì´ë™');
      setCurrentScreen('qr');
      tapCountRef.current = 0;
      return;
    }

    tapTimerRef.current = setTimeout(() => {
      console.log('â±ï¸ íƒ€ì´ë¨¸ ë§Œë£Œ - ì¹´ìš´íŠ¸ ë¦¬ì…‹');
      tapCountRef.current = 0;
    }, 1000);
  }, []);

  // ì™¼ìª½ í™”ë©´ 2ë²ˆ íƒ­ - ë„êµ¬ ì „í™˜
  const handleLeftSideTap = useCallback(() => {
    leftTapCountRef.current += 1;
    console.log(`ğŸ‘† ì™¼ìª½ íƒ­ ${leftTapCountRef.current}/2`);

    if (leftTapTimerRef.current) {
      clearTimeout(leftTapTimerRef.current);
    }

    if (leftTapCountRef.current >= 2) {
      const newTool: ToolType = currentTool === 'chalk' ? 'eraser' : 'chalk';
      setCurrentTool(newTool);
      console.log(`âœ… ë„êµ¬ ì „í™˜: ${newTool === 'eraser' ? 'ì§€ìš°ê°œ' : 'ë¶„í•„'}`);
      leftTapCountRef.current = 0;
      return;
    }

    leftTapTimerRef.current = setTimeout(() => {
      leftTapCountRef.current = 0;
    }, 500);
  }, [currentTool]);

  // ì™¼ìª½ í™”ë©´ ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì‹œì‘
  const handleLeftSidePressIn = useCallback(() => {
    leftLongPressStartRef.current = Date.now();
    
    leftLongPressTimerRef.current = setTimeout(() => {
      console.log('âœ… 2ì´ˆ ê¸¸ê²Œ ëˆ„ë¥´ê¸° - ì „ì²´ í´ë¦¬ì–´!');
      clearCanvas();
    }, 2000);
  }, [clearCanvas]);

  // ì™¼ìª½ í™”ë©´ ê¸¸ê²Œ ëˆ„ë¥´ê¸° ì·¨ì†Œ
  const handleLeftSidePressOut = useCallback(() => {
    if (leftLongPressTimerRef.current) {
      clearTimeout(leftLongPressTimerRef.current);
      leftLongPressTimerRef.current = null;
    }
    
    // 2ì´ˆ ë¯¸ë§Œì´ë©´ íƒ­ìœ¼ë¡œ ì²˜ë¦¬
    const pressDuration = Date.now() - leftLongPressStartRef.current;
    if (pressDuration < 2000) {
      handleLeftSideTap();
    }
  }, [handleLeftSideTap]);

  useEffect(() => {
    return () => {
      if (tapTimerRef.current) clearTimeout(tapTimerRef.current);
      if (leftTapTimerRef.current) clearTimeout(leftTapTimerRef.current);
      if (leftLongPressTimerRef.current) clearTimeout(leftLongPressTimerRef.current);
    };
  }, []);

  // ===== iPad ê·¸ë¦¬ê¸° í•¸ë“¤ëŸ¬ =====
  const handleTouchStart = useCallback((event: any) => {
    const { locationX, locationY } = event.nativeEvent;
    const point: Point = { x: locationX, y: locationY };
    
    setIsDrawing(true);
    currentStrokeRef.current = [point];
    lastRenderTimeRef.current = Date.now();
    
    // ê·¸ë¦¬ê¸° ì‹œì‘ ì‹œì ì˜ ë¡œì»¬ ë ˆì´ì–´ ìˆ˜ ì €ì¥
    baseLayerCountRef.current = localLayersRef.current.length;
    
    console.log(`âœï¸ ${currentTool === 'eraser' ? 'ì§€ìš°ê°œ' : 'ê·¸ë¦¬ê¸°'} ì‹œì‘ (ë¡œì»¬ ë ˆì´ì–´: ${baseLayerCountRef.current})`);
  }, [currentTool]);

  const handleTouchMove = useCallback((event: any) => {
    if (!isDrawing) return;
    
    const { locationX, locationY } = event.nativeEvent;
    const point: Point = { x: locationX, y: locationY };
    
    currentStrokeRef.current.push(point);
    
    const now = Date.now();
    if (now - lastRenderTimeRef.current < renderThrottleMs) {
      return;
    }
    lastRenderTimeRef.current = now;
    
    const tempStroke: Stroke = {
      points: [...currentStrokeRef.current],
      width: currentTool === 'eraser' ? eraserWidth : penWidth,
      tool: currentTool,
    };
    
    // ê¸°ì¤€ ë ˆì´ì–´ê¹Œì§€ë§Œ ìœ ì§€í•˜ê³  ì„ì‹œ ë ˆì´ì–´ ì¶”ê°€
    let newLocalLayers: Layer[] = localLayersRef.current.slice(0, baseLayerCountRef.current);
    
    if (currentTool === 'eraser') {
      const eraserPath = Skia.Path.Make();
      tempStroke.points.forEach((pt, idx) => {
        if (idx === 0) {
          eraserPath.moveTo(pt.x, pt.y);
        } else {
          eraserPath.lineTo(pt.x, pt.y);
        }
      });
      
      newLocalLayers.push({
        kind: 'eraser',
        path: eraserPath,
      });
    } else {
      const { corePath, dustPath } = renderStrokeToPath(tempStroke);
      
      newLocalLayers.push({
        kind: 'chalk',
        corePath,
        dustPath,
      });
    }
    
    setLocalLayers(newLocalLayers);
  }, [isDrawing, currentTool, penWidth, eraserWidth, renderStrokeToPath]);

  const handleTouchEnd = useCallback(() => {
    if (!isDrawing || currentStrokeRef.current.length < 2) {
      setIsDrawing(false);
      currentStrokeRef.current = [];
      return;
    }
    
    const newStroke: Stroke = {
      points: [...currentStrokeRef.current],
      width: currentTool === 'eraser' ? eraserWidth : penWidth,
      tool: currentTool,
      order: globalOrderRef.current++, // ì „ì—­ ìˆœì„œ ë¶€ì—¬
    };
    
    // localStrokesì— ì¶”ê°€í•˜ë©´ useEffectê°€ ìë™ìœ¼ë¡œ ë Œë”ë§
    setLocalStrokes(prev => [...prev, newStroke]);
    
    setIsDrawing(false);
    currentStrokeRef.current = [];
    
    console.log(`âœ… ê·¸ë¦¬ê¸° ì™„ë£Œ (order: ${newStroke.order})`);
  }, [isDrawing, currentTool, penWidth, eraserWidth]);

  // ===== QR ì½”ë“œ í™”ë©´ =====
  if (currentScreen === 'qr') {
    return (
      <SafeAreaView style={styles.qrContainer}>
        <StatusBar barStyle="light-content" />
        
        <View style={styles.qrHeader}>
          <Text style={styles.qrTitle}>Chalkboard iPad</Text>
          {roomId && shareUrl && (
            <TouchableOpacity
              style={styles.goToChalkboardBtn}
              onPress={() => setCurrentScreen('chalkboard')}
            >
              <Text style={styles.arrowText}>â†’</Text>
              <Text style={styles.goToChalkboardText}>Board</Text>
            </TouchableOpacity>
          )}
        </View>

        <View style={styles.qrContent}>
          {!shareUrl ? (
            <View style={styles.loadingBox}>
              <Text style={styles.loadingText}>â³ Generating QR Code...</Text>
            </View>
          ) : (
            <>
              <View style={styles.qrCodeBox}>
                <QRCode value={shareUrl} size={300} backgroundColor="white" />
              </View>

              <View style={styles.infoBox}>
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Room ID</Text>
                  <Text style={styles.infoValue}>{roomId}</Text>
                </View>
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Connection</Text>
                  <Text style={[styles.infoValue, dbConnected && styles.infoValueConnected]}>
                    {dbConnected ? 'âœ… Connected' : 'â³ Connecting'}
                  </Text>
                </View>
                <View style={styles.infoRow}>
                  <Text style={styles.infoLabel}>Assistant</Text>
                  <Text style={[styles.infoValue, assistantOnlineCount > 0 && styles.infoValueConnected]}>
                    {assistantOnlineCount > 0 ? `âœ… Connected (${assistantOnlineCount})` : 'â³ Waiting'}
                  </Text>
                </View>
              </View>

              <View style={styles.instructionBox}>
                <Text style={styles.instructionText}>
                  ğŸ’¡ ì¹ íŒ í™”ë©´ ì‚¬ìš©ë²•
                </Text>
                <Text style={styles.instructionSubText}>
                  â€¢ ëª¨ì„œë¦¬ 3ë²ˆ íƒ­: QR í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°{'\n'}
                  â€¢ ì™¼ìª½ 2ë²ˆ íƒ­: ë¶„í•„/ì§€ìš°ê°œ ì „í™˜{'\n'}
                  â€¢ ì™¼ìª½ 2ì´ˆ ê¸¸ê²Œ ëˆ„ë¥´ê¸°: ì „ì²´ ì§€ìš°ê¸°
                </Text>
              </View>
            </>
          )}
        </View>

        {shareUrl && (
          <View style={styles.settingsContainer}>
            {/* íœìŠ¬ í¬ê¸° */}
            <View style={styles.settingSection}>
              <Text style={styles.settingLabel}>ë¶„í•„ í¬ê¸°: {Math.round(penWidth)}</Text>
              <Slider
                style={styles.slider}
                minimumValue={5}
                maximumValue={50}
                value={penWidth}
                onValueChange={setPenWidth}
                minimumTrackTintColor="#1f6feb"
                maximumTrackTintColor="#333"
                thumbTintColor="#1f6feb"
              />
              <View style={styles.penPreview}>
                <View
                  style={[
                    styles.penPreviewDot,
                    {
                      width: penWidth * 2,
                      height: penWidth * 2,
                      borderRadius: penWidth,
                      backgroundColor: 'rgba(230, 235, 228, 0.60)',
                    },
                  ]}
                />
              </View>
            </View>

            {/* ì§€ìš°ê°œ í¬ê¸° */}
            <View style={styles.settingSection}>
              <Text style={styles.settingLabel}>ì§€ìš°ê°œ í¬ê¸°: {Math.round(eraserWidth)}</Text>
              <Slider
                style={styles.slider}
                minimumValue={20}
                maximumValue={100}
                value={eraserWidth}
                onValueChange={setEraserWidth}
                minimumTrackTintColor="#ff6b6b"
                maximumTrackTintColor="#333"
                thumbTintColor="#ff6b6b"
              />
              <View style={styles.penPreview}>
                <View
                  style={[
                    styles.penPreviewDot,
                    {
                      width: eraserWidth,
                      height: eraserWidth,
                      borderRadius: eraserWidth / 2,
                      backgroundColor: '#333',
                      borderWidth: 2,
                      borderColor: '#666',
                    },
                  ]}
                />
              </View>
            </View>
          </View>
        )}
      </SafeAreaView>
    );
  }

  // ===== ì¹ íŒ í™”ë©´ =====
  return (
    <ImageBackground
      source={require('./assets/chalkboard-background.png')}
      style={styles.chalkboardContainer}
      resizeMode="cover"
    >
      <StatusBar hidden />
      
      {/* ì™¼ìª½ ìƒë‹¨ ëª¨ì„œë¦¬ - QR ë³µê·€ */}
      <TouchableOpacity
        style={styles.cornerTapArea}
        onPress={handleCornerTap}
        activeOpacity={1}
      />

      {/* ì˜¤ë¥¸ìª½ ìƒë‹¨ ëª¨ì„œë¦¬ - QR ë³µê·€ */}
      <TouchableOpacity
        style={[styles.cornerTapArea, styles.cornerTapAreaRight]}
        onPress={handleCornerTap}
        activeOpacity={1}
      />

      {/* ì™¼ìª½ í•˜ë‹¨ ëª¨ì„œë¦¬ - QR ë³µê·€ */}
      <TouchableOpacity
        style={[styles.cornerTapArea, styles.cornerTapAreaBottomLeft]}
        onPress={handleCornerTap}
        activeOpacity={1}
      />

      {/* ì˜¤ë¥¸ìª½ í•˜ë‹¨ ëª¨ì„œë¦¬ - QR ë³µê·€ */}
      <TouchableOpacity
        style={[styles.cornerTapArea, styles.cornerTapAreaBottomRight]}
        onPress={handleCornerTap}
        activeOpacity={1}
      />

      {/* ì™¼ìª½ ì¤‘ì•™ ì˜ì—­ - ë„êµ¬ ì „í™˜ (2ë²ˆ íƒ­) + ì „ì²´ í´ë¦¬ì–´ (2ì´ˆ ê¸¸ê²Œ ëˆ„ë¥´ê¸°) */}
      <TouchableOpacity
        style={styles.leftSideArea}
        onPressIn={handleLeftSidePressIn}
        onPressOut={handleLeftSidePressOut}
        activeOpacity={1}
      />

      {/* ì§€ìš°ê°œ ëª¨ë“œ í‘œì‹œ - ì™¼ìª½ì— ì‘ì€ ì  */}
      {currentTool === 'eraser' && (
        <View style={styles.eraserIndicator}>
          <View style={styles.eraserDot} />
        </View>
      )}

      {/* ê·¸ë¦¬ê¸° ì˜ì—­ */}
      <View
        style={styles.drawingArea}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onTouchCancel={handleTouchEnd}
      >
        {/* í•˜ë‚˜ì˜ Canvasì—ì„œ ëª¨ë“  ë ˆì´ì–´ë¥¼ order ìˆœì„œëŒ€ë¡œ ë Œë”ë§ */}
        <Canvas style={styles.canvas}>
          {[...externalLayers, ...localLayers]
            .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))
            .map((l, idx) => {
              if (l.kind === 'eraser' && l.path) {
                return (
                  <SkPath
                    key={`er-${l.order}-${idx}`}
                    path={l.path}
                    color="rgba(0,0,0,1)"
                    style="stroke"
                    strokeWidth={eraserWidth}
                    strokeCap="round"
                    strokeJoin="round"
                    blendMode="clear"
                  />
                );
              }
              if (l.kind === 'chalk' && l.dustPath && l.corePath) {
                return (
                  <Group key={`ch-${l.order}-${idx}`}>
                    <SkPath path={l.dustPath} color={CHALK_DUST} style="fill" />
                    <SkPath path={l.corePath} color={CHALK_CORE} style="fill" />
                  </Group>
                );
              }
              return null;
            })}
        </Canvas>
      </View>
    </ImageBackground>
  );
}

const styles = StyleSheet.create({
  // ===== QR ì½”ë“œ í™”ë©´ =====
  qrContainer: {
    flex: 1,
    backgroundColor: '#0b0b0b',
  },
  qrHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#333',
  },
  qrTitle: {
    color: '#fff',
    fontSize: 24,
    fontWeight: '700',
  },
  goToChalkboardBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#1f6feb',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 12,
    gap: 8,
  },
  arrowText: {
    color: '#fff',
    fontSize: 20,
    fontWeight: '700',
  },
  goToChalkboardText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '700',
  },
  qrContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingBox: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  loadingText: {
    color: '#999',
    fontSize: 18,
    fontWeight: '600',
  },
  qrCodeBox: {
    backgroundColor: '#fff',
    padding: 30,
    borderRadius: 20,
    marginBottom: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 10,
    elevation: 8,
  },
  infoBox: {
    backgroundColor: '#151515',
    padding: 20,
    borderRadius: 16,
    width: '100%',
    maxWidth: 500,
    gap: 12,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  infoLabel: {
    color: '#999',
    fontSize: 16,
    fontWeight: '600',
  },
  infoValue: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '700',
  },
  infoValueConnected: {
    color: '#00ff88',
  },
  
  instructionBox: {
    backgroundColor: '#1a1a2e',
    padding: 16,
    borderRadius: 12,
    marginTop: 24,
    width: '100%',
    maxWidth: 500,
    borderWidth: 1,
    borderColor: '#2a2a4e',
  },
  instructionText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '700',
    marginBottom: 8,
  },
  instructionSubText: {
    color: '#9ca3af',
    fontSize: 14,
    lineHeight: 22,
  },
  
  settingsContainer: {
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#333',
    backgroundColor: '#151515',
    gap: 24,
  },
  settingSection: {
    gap: 8,
  },
  settingLabel: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  slider: {
    width: '100%',
    height: 40,
  },
  penPreview: {
    alignItems: 'center',
    justifyContent: 'center',
    height: 60,
    marginTop: 8,
  },
  penPreviewDot: {
    // ë™ì ìœ¼ë¡œ ì„¤ì •ë¨
  },

  // ===== ì¹ íŒ í™”ë©´ =====
  chalkboardContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  },
  cornerTapArea: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: 80,
    height: 80,
    zIndex: 100,
    backgroundColor: 'transparent',
  },
  cornerTapAreaRight: {
    left: undefined,
    right: 0,
  },
  cornerTapAreaBottomLeft: {
    top: undefined,
    bottom: 0,
  },
  cornerTapAreaBottomRight: {
    top: undefined,
    left: undefined,
    bottom: 0,
    right: 0,
  },
  
  // ì™¼ìª½ ì¤‘ì•™ ì˜ì—­ (ë„êµ¬ ì „í™˜ + ì „ì²´ í´ë¦¬ì–´)
  leftSideArea: {
    position: 'absolute',
    left: 0,
    top: '30%',
    width: 100,
    height: '40%',
    zIndex: 99,
    backgroundColor: 'transparent',
  },
  
  // ì§€ìš°ê°œ ëª¨ë“œ í‘œì‹œ
  eraserIndicator: {
    position: 'absolute',
    left: 20,
    top: '50%',
    zIndex: 101,
    transform: [{ translateY: -4 }],
  },
  eraserDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#000',
  },
  
  drawingArea: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  },
  canvas: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: SCREEN_WIDTH,
    height: SCREEN_HEIGHT,
  },
});
